<?php
/** 
 * PDOStatementExtended.php
 * Generated by PhpStorm - 11/2014
 * Project PDOExtended
 * @author Beno!t POLASZEK
**/

namespace BenTools\PDOExtended;
use PDO, PDOStatement;

/**
 * PDO Statement Extended - allowing debug of queries
 * @author Beno!t POLASZEK - 2013
 */
class PDOStatementExtended extends PDOStatement {

    public      $queryString    =   '';
    protected   $preview        =   '';
    protected   $duration       =   0.00;
    protected   $executed       =   false;
    protected   $execCount      =   0;
    protected   $totalDuration  =   0.00;
    protected   $boundValues    =   array();
    protected   $keywords       =   array();

    /**
     * When bindValue() is called, we store its params
     * @param mixed $parameter
     * @param mixed $value
     * @param null  $PDOType
     * @return $this
     */
    public function bindValue($parameter, $value, $PDOType = null) {

        if (is_string($parameter) && strpos($parameter, ':') !== 0)
            $parameter  =   ':' . $parameter;

        # Flush Bound Values if statement has previously been executed
        if ($this->executed) {
            $this->boundValues  =   array();
            $this->executed     =   false;
        }

        $this->boundValues[]    =    array('k' => $parameter, 'v' => $value, 't' => is_null($PDOType) ? self::PDOType($value) : $PDOType);
        parent::bindValue($parameter, $value, $PDOType);
        return $this;
    }

    /**
     * Binds several values at once
     * @param array $sqlValues
     * @return $this
     */
    public function bindValues($sqlValues = array()) {

        if (empty($sqlValues))
            return $this;

        if (!is_array($sqlValues))
            $sqlValues  =    array($sqlValues);

        foreach ($sqlValues AS $key => $value)

            if (is_numeric($key))
                $this   ->  bindValue((int) $key + 1, $value, self::PDOType($value));

            else
                $this   ->  bindValue(':' . $key, $value, self::PDOType($value));

        return $this;
    }

    /**
     * Executes query, measures the total time
     * @param null $input_parameters
     * @return $this for fluent interface
     */
    public function execute($input_parameters = null) {

        $start                  =    microtime(true);
        parent::execute($input_parameters);
        $end                    =    microtime(true);

        $this->duration         =    round($end - $start, 4);
        $this->totalDuration    +=   $this->duration;
        $this->executed         =    true;
        $this->execCount++;
        $this->preview          =   null;

        return $this;
    }

    /**
     * setFetchMode() override, allowing fluent interface
     * @param int $mode
     * @return $this
     */
    public function setFetchMode($mode, $params = NULL) {
        call_user_func_array(array('parent', 'setFetchMode'), func_get_args());
        return $this;
    }

    /**
     * Executes the statement with bounded params
     *
     * @param array $sqlValues : Optional PDO Values to bind
     * @return PDOStatementExtended instance
     */
    public function sql($sqlValues = array()) {
        return $this->bindValues($sqlValues)->execute();
    }

    /**
     * SqlArray executes Query : returns the whole result set
     *
     * @param array $sqlValues : Optional PDO Values to bind
     * @return array
     */
    public function sqlArray($sqlValues = array()) {
        return $this->bindValues($sqlValues)->execute()->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * SqlRow executes Query : returns the 1st row of your result set
     *
     * @param array $sqlValues : Optional PDO Values to bind
     * @return array
     */
    public function sqlRow($sqlValues = array()) {
        return $this->bindValues($sqlValues)->execute()->fetch(PDO::FETCH_ASSOC);
    }

    /**
     * SqlValues executes Query : returns the 1st column of your result set
     *
     * @param array $sqlValues : Optional PDO Values to bind
     * @return array
     */
    public function sqlColumn($sqlValues = array()) {
        return $this->bindValues($sqlValues)->execute()->fetchAll(PDO::FETCH_COLUMN);
    }

    /**
     * SqlValue executes Query : returns the 1st cell of your result set
     *
     * @param array $sqlValues : Optional PDO Values to bind
     * @return string
     */
    public function sqlValue($sqlValues = array()) {
        return $this->bindValues($sqlValues)->execute()->fetch(PDO::FETCH_COLUMN);
    }

    /**
     * sqlObject executes Query : returns an hydrated object from the given class / object
     * @param       $class - can be an existing object or a class name
     * @param array $sqlValues : Optional PDO Values to bind
     * @return object
     */
    public function sqlObject($class, $sqlValues = array()) {
        if (is_object($class))
            return $this->setFetchMode(PDO::FETCH_INTO, $class)->bindValues($sqlValues)->execute()->fetch(PDO::FETCH_INTO);
        else
            return $this->setFetchMode(PDO::FETCH_CLASS, $class)->bindValues($sqlValues)->execute()->fetch(PDO::FETCH_CLASS);
    }

    /**
     * sqlObjects executes Query : returns an array of hydrated objects from the given class
     * @param       $class - can be a class name only
     * @param array $sqlValues : Optional PDO Values to bind
     * @return array
     */
    public function sqlObjects($class, $sqlValues = array()) {
        if (is_object($class))
            $class = get_class($class);
        $this->setFetchMode(PDO::FETCH_CLASS, $class)->bindValues($sqlValues)->execute();
        $result = array();
        while ($object = $this->fetch(PDO::FETCH_CLASS))
            $result[] = $object;
        return $result;
    }

    /**
     * SqlAssoc executes Query :
     * If $dataType == self::TO_STRING : returns an associative array where the 1st column is the key and the 2nd is the value
     * If $dataType == self::TO_STDCLASS : returns an associative array where the 1st column is the key the others are properties of an anonymous object
     * If $dataType == self::TO_ARRAY_ASSOC : returns an associative array where the 1st column is the key the others are an associative array
     * If $dataType == self::TO_ARRAY_INDEX : returns an associative array where the 1st column is the key the others are an indexed array
     *
     * @param array $sqlValues : PDO Values to bind
     * @param int $dataType : type of data wanted
     * @return array
     */
    public function sqlAssoc($sqlValues = array(), $dataType = PDOExtended::TO_STRING) {
        $data    =    $this->bindValues($sqlValues)->execute()->fetch(PDO::FETCH_ASSOC);

        if ($data) {
            $keys    =    array_keys($data);

            if ($dataType == PDOExtended::TO_STDCLASS)
                $result    =    array($data[$keys[0]] => (object) array_slice($data, 1));

            elseif ($dataType == PDOExtended::TO_ARRAY_ASSOC)
                $result    =    array($data[$keys[0]] => array_slice($data, 1));

            elseif ($dataType == PDOExtended::TO_ARRAY_INDEX)
                $result    =    array($data[$keys[0]] => array_values(array_slice($data, 1)));

            else // $dataType == PDOExtended::TO_STRING by default
                $result    =    array($data[$keys[0]] => $data[$keys[1]]);

            return $result;
        }

        else {
            return $data;
        }

    }

    /**
     * SqlMultiAssoc executes Query :
     * If $dataType == self::TO_STRING : returns an associative array where the 1st column is the key and the 2nd is the value
     * If $dataType == self::TO_STDCLASS : returns an associative array where the 1st column is the key the others are properties of an anonymous object
     * If $dataType == self::TO_ARRAY_ASSOC : returns an associative array where the 1st column is the key the others are an associative array
     * If $dataType == self::TO_ARRAY_INDEX : returns an associative array where the 1st column is the key the others are an indexed array
     *
     * @param array $sqlValues : PDO Values to bind
     * @param int $dataType : type of data wanted
     * @return array
     */
    public function sqlMultiAssoc($sqlValues = array(), $dataType = PDOExtended::TO_STRING) {
        $data    =    $this->bindValues($sqlValues)->execute()->fetchAll(PDO::FETCH_ASSOC);

        if (array_key_exists(0, $data)) :

            $keys       =    array_keys($data[0]);
            $result     =    array();

            foreach ($data AS $item)

                if ($dataType == PDOExtended::TO_STDCLASS)
                    $result[]    =    array($item[$keys[0]] => (object) array_slice($item, 1));

                elseif ($dataType == PDOExtended::TO_ARRAY_ASSOC)
                    $result[]    =    array($item[$keys[0]] => array_slice($item, 1));

                elseif ($dataType == PDOExtended::TO_ARRAY_INDEX)
                    $result[]    =    array($item[$keys[0]] => array_values(array_slice($item, 1)));

                else // $dataType == PDOExtended::TO_STRING by default
                    $result[]    =    array($item[$keys[0]] => $item[$keys[1]]);

            return $result;

        else :
            return $data;

        endif;

    }

    /**
     * PDOStatementExtended debug function
     *
     * @return PDOStatementExtended instance
     * @author Beno!t POLASZEK - Jun 2013
     */
    public function debug() {

        $this->keywords     =    array();
        $this->preview      =    preg_replace("#\t+#", "\t", $this->queryString);

        # Case of question mark placeholders
        if (array_key_exists(0, $this->boundValues) && $this->boundValues[0]['k'] === 1)
            foreach ($this->boundValues AS $boundValue)
                $this->preview    =    preg_replace("/([\?])/", self::DebugValue($boundValue), $this->preview, 1);

        # Case of named placeholders
        else
            foreach ($this->boundValues AS $boundValue)
                $this->keywords[]    =    $boundValue['k'];

        foreach ($this->keywords AS $word)
            foreach ($this->boundValues AS $boundValue)
                if ($boundValue['k'] == $word)
                    $this->preview    =    preg_replace("/(\:\b".substr($word, 1)."\b)/i", self::DebugValue($boundValue), $this->preview);

        return $this;
    }

    /**
     * Alias
     * @return string
     */
    public function preview() {
        return $this->getPreview();
    }

    /**
     * string context => query preview
     */
    public function __toString() {
        return (string) $this->queryString;
    }

    /**
     * Add quotes or not for Debug() method
     */
    private static function DebugValue($boundParam) {
        if (in_array($boundParam['t'], array(PDO::PARAM_BOOL, PDO::PARAM_INT)))
            return (int) $boundParam['v'];

        elseif ($boundParam['t'] == PDO::PARAM_NULL)
            return 'NULL';

        else
            return (string) "'". addslashes($boundParam['v']) . "'";
    }

    /**
     * Transforms an indexed array into placeholders
     * Example : array(0, 22, 99) ==> '?,?,?'
     * Usage : "WHERE VALUES IN (". PDOStatementExtended::PlaceHolders($MyArray) .")"
     *
     * @param array $array
     * @return string placeholder
     * @author Beno!t POLASZEK - Jun 2013
     */
    public static function PlaceHolders($array = array()) {
        return implode(',', array_fill(0, count($array), '?'));
    }

    /**
     * PDO Automatic type binding
     *
     * @param mixed $var
     * @return PDO const
     */
    public static function PDOType($var) {

        switch (strtolower(gettype($var))) :

            case 'string'   :
                return (strtoupper($var) == 'NULL') ? PDO::PARAM_NULL : PDO::PARAM_STR;

            case 'int'      :
            case 'integer'  :
                return PDO::PARAM_INT;

            case 'double'   :
            case 'float'    :
                return PDO::PARAM_STR; // No float PDO type at the moment... :(

            case 'bool'     :
            case 'boolean'  :
                return PDO::PARAM_BOOL;

            case 'null'     :
                return PDO::PARAM_NULL;

            default         :
                return PDO::PARAM_STR;

        endswitch;

    }

    /**
     * @return array
     */
    public function getKeywords() {
        if (!$this->preview)
            $this->debug();
        return $this->keywords;
    }

    /**
     * @return array
     */
    public function getBoundValues() {
        return $this->boundValues;
    }

    /**
     * @return string
     */
    public function getQueryString() {
        return $this->queryString;
    }

    /**
     * @return string
     */
    public function getPreview() {
        if (!$this->preview)
            $this->debug();
        return $this->preview;
    }

    /**
     * @return float
     */
    public function getDuration() {
        return $this->duration;
    }

    /**
     * @return boolean
     */
    public function getExecuted() {
        return $this->executed;
    }

    /**
     * @return int
     */
    public function getExecCount() {
        return $this->execCount;
    }

    /**
     * @return float
     */
    public function getTotalDuration() {
        return $this->totalDuration;
    }
}