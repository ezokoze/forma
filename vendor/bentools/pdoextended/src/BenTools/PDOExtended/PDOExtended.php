<?php
/** 
 * PDOExtended.php
 * Generated by PhpStorm - 11/2014
 * Project PDOExtended
 * @author Beno!t POLASZEK
**/

namespace BenTools\PDOExtended;
use PDO;

class PDOExtended extends PDO {

    /**
     * @var PDO
     */
    protected       $pdo;

    /**
     * @var CacheHandler\CacheHandlerInterface
     */
    protected       $cacheHandler;

    protected       $cacheTtl               =   0;
    protected       $dsn                    =   '';
    protected       $username               =   '';
    protected       $password               =   '';
    protected       $driver_options         =   array();
    protected       $isPaused               =   false;
    protected       $latestStmt;

    const           TO_ARRAY_ASSOC          =    1;
    const           TO_ARRAY_INDEX          =    2;
    const           TO_STRING               =    3;
    const           TO_STDCLASS             =    4;
    const           DEFAULT_CACHE_HANDLER   =   '\BenTools\PDOExtended\CacheHandler\ArrayCache';

    /**
     * @param string                             $dsn
     * @param string                             $username
     * @param string                             $passwd
     * @param array                              $options
     * @param bool                               $connect
     * @param CacheHandler\CacheHandlerInterface $cacheHandler
     */
    public function __construct($dsn = null, $username = null, $passwd = null, $options = array(), $connect = true, CacheHandler\CacheHandlerInterface $cacheHandler = null) {
        $this   ->  setDsn($dsn)
                ->  setUsername($username)
                ->  setPassword($passwd)
                ->  setDriverOptions($options);

        if (is_null($cacheHandler) && is_null($this->getCacheHandler()))
            $cacheHandlerClass = static::DEFAULT_CACHE_HANDLER AND $this->setCacheHandler(new $cacheHandlerClass);

        $connect ?  $this->connect() : $this->pause();
    }

    /**
     * @return $this
     */
    public function connect() {
        if (!$this->getPdo())
            $this->setPdo(new PDO($this->getDsn(), $this->getUsername(), $this->getPassword(), $this->getDriverOptions()));
        $this->isPaused =   false;
        return $this;
    }

    /**
     * @return $this
     */
    public function disconnect() {
        $this->getCacheHandler()->clear();
        $this->pdo  =   null;
        return $this;
    }

    /**
     * Pauses the connection
     * @return $this
     */
    public function pause() {
        $this->disconnect();
        $this->isPaused =   true;
        return $this;
    }

    /**
     * @return boolean
     */
    public function isPaused() {
        return $this->isPaused;
    }

    /**
     * @return bool
     */
    public function isConnected() {
        return $this->getPdo() instanceof PDO;
    }

    /**
     * Prepares a SQL Statement and executes it
     */
    public function sql($sqlString, $sqlValues = array(), $driver_options = array()) {

        # If the connection was paused, we have to reconnect
        $this->checkConnection();

        # If sqlString isn't a PDOStatement yet
        $stmt    =    ($sqlString instanceof \PDOStatement) ? $sqlString : $this->prepare($sqlString, array(), $driver_options);

        # If values have been provided, let's bind them
        if (!empty($sqlValues))
            $stmt->bindValues($sqlValues);

        # Execution
        try {
            $stmt->execute();
            $this->setLatestStmt($stmt);
        }

        # Custom PDO Exception, allowing query preview
        catch (\PDOException $PDOException) {
            if (get_class($PDOException) == 'PDOException')
                throw new PDOStatementExtendedException((string) $PDOException->getMessage(), $PDOException->getCode(), $PDOException, $stmt->debug());
        }
        # The statement is executed. You can now use fetch() and fetchAll() methods.
        return $stmt;
    }

    /**
     * sqlArray executes Query : returns the whole result set
     *
     * @param mixed $sqlString : SQL Query (String or instanceof PDOStatement)
     * @param array $sqlValues : Optional PDO Values to bind
     * @return array
     */
    public function sqlArray($sqlString, $sqlValues = array()) {
        return $this->prepare($sqlString)->sqlArray($sqlValues);
    }
    /**
     * sqlRow executes Query : returns the 1st row of your result set
     *
     * @param mixed $sqlString : SQL Query (String or instanceof PDOStatement)
     * @param array $sqlValues : Optional PDO Values to bind
     * @return array
     */
    public function sqlRow($sqlString, $sqlValues = array()) {
        return $this->prepare($sqlString)->sqlRow($sqlValues);
    }

    /**
     * sqlValues executes Query : returns the 1st column of your result set
     *
     * @param mixed $sqlString : SQL Query (String or instanceof PDOStatement)
     * @param array $sqlValues : Optional PDO Values to bind
     * @return array
     */
    public function sqlColumn($sqlString, $sqlValues = array()) {
        return $this->prepare($sqlString)->sqlColumn($sqlValues);
    }

    /**
     * sqlValue executes Query : returns the 1st cell of your result set
     *
     * @param mixed $sqlString : SQL Query (String or instanceof PDOStatement)
     * @param array $sqlValues : Optional PDO Values to bind
     * @return string
     */
    public function sqlValue($sqlString, $sqlValues = array()) {
        return $this->prepare($sqlString)->sqlValue($sqlValues);
    }

    /**
     * sqlObject executes Query : returns an hydrated object from the given class / object
     * @param       $sqlString : SQL Query (String or instanceof PDOStatement)
     * @param       $class - can be an existing object or a class name
     * @param array $sqlValues : Optional PDO Values to bind
     * @return object
     */
    public function sqlObject($sqlString, $class, $sqlValues = array()) {
        return $this->prepare($sqlString)->sqlObject($class, $sqlValues);
    }

    /**
     * sqlObjects executes Query : returns an array of hydrated objects from the given class
     * @param       $sqlString : SQL Query (String or instanceof PDOStatement)
     * @param       $class - can be a class name only
     * @param array $sqlValues : Optional PDO Values to bind
     * @return array
     */
    public function sqlObjects($sqlString, $class, $sqlValues = array()) {
        return $this->prepare($sqlString)->sqlObjects($class, $sqlValues);
    }

    /**
     * sqlAssoc executes Query :
     * If $dataType == self::TO_STRING : returns an associative array where the 1st column is the key and the 2nd is the value
     * If $dataType == self::TO_STDCLASS : returns an associative array where the 1st column is the key the others are properties of an anonymous object
     * If $dataType == self::TO_ARRAY_ASSOC : returns an associative array where the 1st column is the key the others are an associative array
     * If $dataType == self::TO_ARRAY_INDEX : returns an associative array where the 1st column is the key the others are an indexed array
     *
     * @param mixed $sqlString : SQL Query (String or instanceof PDOStatement)
     * @param array $sqlValues : PDO Values to bind
     * @param int $dataType : type of data wanted
     * @return array
     */
    public function sqlAssoc($sqlString, $sqlValues = array(), $dataType = self::TO_STRING) {
        return $this->prepare($sqlString)->sqlAssoc($sqlValues, $dataType);
    }

    /**
     * sqlMultiAssoc executes Query :
     * If $dataType == self::TO_STRING : returns an associative array where the 1st column is the key and the 2nd is the value
     * If $dataType == self::TO_STDCLASS : returns an associative array where the 1st column is the key the others are properties of an anonymous object
     * If $dataType == self::TO_ARRAY_ASSOC : returns an associative array where the 1st column is the key the others are an associative array
     * If $dataType == self::TO_ARRAY_INDEX : returns an associative array where the 1st column is the key the others are an indexed array
     *
     * @param mixed $sqlString : SQL Query as a string or a PDOStatementExtended
     * @param array $sqlValues : PDO Values to bind
     * @param int $dataType : type of data wanted
     * @return array
     */
    public function sqlMultiAssoc($sqlString, $sqlValues = array(), $dataType = self::TO_STRING) {
        return $this->prepare($sqlString)->sqlMultiAssoc($sqlValues, $dataType);
    }

    /**
     * @param string $sqlString
     * @param array  $options
     * @return PDOStatementExtended
     */
    public function prepare($sqlString, $options = array()) {

        $this->checkConnection();

        if ($sqlString instanceof PDOStatementExtended)
            $stmt   =   $sqlString;

        else {

            if ($this->getCacheHandler()->exists($this->getCacheHandler()->key($sqlString)))
                $stmt   =   $this->getCacheHandler()->fetch($this->getCacheHandler()->key($sqlString));

            else
                $stmt   =   $this->getCacheHandler()->store($this->getCacheHandler()->key($sqlString), $this->getPdo()->prepare($sqlString, $options), $this->getCacheTtl());

        }

        $this->setLatestStmt($stmt);

        return $stmt;
    }

    /**
     * @return bool
     */
    public function beginTransaction() {
        $this->checkConnection();
        return $this->getPdo()->beginTransaction();
    }

    /**
     * @return bool
     */
    public function commit() {
        $this->checkConnection();
        return $this->getPdo()->commit();
    }

    /**
     * @return bool
     */
    public function rollBack() {
        $this->checkConnection();
        return $this->getPdo()->rollBack();
    }

    /**
     * @return bool
     */
    public function inTransaction() {
        $this->checkConnection();
        return $this->getPdo()->inTransaction();
    }

    /**
     * @param int   $attribute
     * @param mixed $value
     * @return bool
     */
    public function setAttribute($attribute, $value) {
        $this->checkConnection();
        return $this->getPdo()->setAttribute($attribute, $value);
    }

    /**
     * @param string $statement
     * @return int
     */
    public function exec($statement) {
        $this->checkConnection();
        return $this->getPdo()->exec($statement);
    }

    /**
     * @param string $statement
     * @return \PDOStatement
     */
    public function query($statement) {
        $this->checkConnection();
        return $this->getPdo()->query($statement);
    }

    /**
     * @param null $name
     * @return string
     */
    public function lastInsertId($name = null) {
        $this->checkConnection();
        return $this->getPdo()->lastInsertId($name);
    }

    /**
     * @return mixed
     */
    public function errorCode() {
        $this->checkConnection();
        return $this->getPdo()->errorCode();
    }

    /**
     * @return array
     */
    public function errorInfo() {
        $this->checkConnection();
        return $this->getPdo()->errorInfo();
    }

    /**
     * @param int $attribute
     * @return mixed
     */
    public function getAttribute($attribute) {
        $this->checkConnection();
        return $this->getPdo()->getAttribute($attribute);
    }

    /**
     * @param string $string
     * @param int    $parameter_type
     * @return string
     */
    public function quote($string, $parameter_type = PDO::PARAM_STR) {
        $this->checkConnection();
        return $this->getPdo()->quote($string, $parameter_type);
    }

    /**
     * @return PDO
     */
    public function getPdo() {
        return $this->pdo;
    }

    /**
     * @param PDO $pdo
     * @return $this - Provides Fluent Interface
     */
    public function setPdo(PDO $pdo) {
        $this->pdo  = $pdo;
        $this->pdo  ->  setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        $this->pdo  ->  setAttribute(PDO::ATTR_STATEMENT_CLASS, array(__NAMESPACE__ . '\PDOStatementExtended'));
        return $this;
    }

    /**
     * @return string
     */
    public function getDsn() {
        return $this->dsn;
    }

    /**
     * @param string $dsn
     * @return $this - Provides Fluent Interface
     */
    public function setDsn($dsn) {
        $this->dsn = $dsn;
        return $this;
    }

    /**
     * @return string
     */
    public function getUsername() {
        return $this->username;
    }

    /**
     * @param string $username
     * @return $this - Provides Fluent Interface
     */
    public function setUsername($username) {
        $this->username = $username;
        return $this;
    }

    /**
     * @return string
     */
    public function getPassword() {
        return $this->password;
    }

    /**
     * @param string $password
     * @return $this - Provides Fluent Interface
     */
    public function setPassword($password) {
        $this->password = $password;
        return $this;
    }

    /**
     * @return array
     */
    public function getDriverOptions() {
        return $this->driver_options;
    }

    /**
     * @param array $driver_options
     * @return $this - Provides Fluent Interface
     */
    public function setDriverOptions(array $driver_options) {
        $this->driver_options = $driver_options;
        return $this;
    }

    /**
     * @return CacheHandler\CacheHandlerInterface
     */
    public function getCacheHandler() {
        return $this->cacheHandler;
    }

    /**
     * @param CacheHandler\CacheHandlerInterface $cacheHandler
     * @return $this - Provides Fluent Interface
     */
    public function setCacheHandler(CacheHandler\CacheHandlerInterface $cacheHandler) {
        $this->cacheHandler = $cacheHandler;
        return $this;
    }

    /**
     * @return int
     */
    public function getCacheTtl() {
        return $this->cacheTtl;
    }

    /**
     * @param int $cacheTtl
     * @return $this - Provides Fluent Interface
     */
    public function setCacheTtl($cacheTtl) {
        $this->cacheTtl = (int) $cacheTtl;
        return $this;
    }

    /**
     * Stores the latest statement
     *
     * @param PDOStatementExtended $Stmt
     * @return $this - current instance
     * @access protected
     * @author Beno!t POLASZEK -  2013
     */
    protected function setLatestStmt(\PDOStatement $Stmt) {
        $this->latestStmt    =    $Stmt;
        return $this;
    }

    /**
     * Retrieves the latest statement
     *
     * @return PDOStatementExtended
     * @access public
     * @author Beno!t POLASZEK -  2013
     */
    public function getLatestStmt() {
        return $this->latestStmt;
    }

    /**
     * Checks connection status
     */
    public function checkConnection() {
        if ($this->isPaused())
            $this->connect();
        if (!$this->isConnected())
            $this->throwNotConnectedException();
    }

    /**
     * @throws PDOExceptionExtended
     */
    protected function throwNotConnectedException() {
        throw new PDOExceptionExtended("You're not connected.");
    }

    /**
     * @param Pdo $pdo
     * @param array $driver_options
     * @param string $cache_handler
     * @return self
     */
    public static function NewInstanceFromPdo(\Pdo $pdo, $driver_options = []) {
        $cnx    =   new static(null, null, null, $driver_options, false);
        $cnx    ->  setPdo($pdo);
        return $cnx;
    }

}